# SAMPL - Sound And Modern Programming Language

<img src="./logo.jpeg" width="80%" />

It is a JVM language that embraces the functional programming paradigm, which currently supports 
immutable data structures, null safety, pattern matching, currying, limited type inference, and 
limited interop with other JVM languages.

## Scope of this Project

This project aims to implement a type-checker, interpreter, and compiler for this language. 

The type-checker will be invoked before both interpretation and compilation to reject all ill-formed
code before running. We aim to design a sound type system for this language without any 
qualification, so this language does not support type cast that can potentially produce type errors
at runtime.

The interpreter will not be an REPL. Instead, it only supports the interpretation of an entire 
program. The compiler will compile the source code of this language to Kotlin code, then invoke
the Kotlin compiler to compile it to Java bytecode. This design allows rapid prototyping and lets
the generated bytecode have excellent integration with Kotlin codebase.

## Notable Features

### Type Inference

```kotlin
class TypeInferenceDemo {
  val a = 42
  val b = a + 4
  fun main(): Int = a + b
}
```

### Pattern Matching

```
class Optional<T>(None | Some of T) {
   fun <T> hasValue(v: Optional<T>): Bool = 
     match v with
     | None -> false
     | Some _ -> true
}
```

### Currying

```kotlin
class CurryingDemo {
  fun add(a: Int, b: Int): Int = a + b
  class Nested {
     val add1 = add(1)
     fun main(): Int = add1(2)
  }
}
```

## Documentations

**Note: Currently, the documentations listed below are very incomplete.**

- Read the [language spec](./LANGUAGE_SPEC.md) for a precise definition of the language features.

- Read the [design document](./DESIGN_DOCS.md) to understand the overall design and architecture.

## Developer Notes

To reduce the size of the package, we do not add the Kotlin compiler as a dependency. If you need
a self-contained package, you can easily wrap it. The reason is that people may only need the 
interpreter features, so the 30M Kotlin compiler is completely useless to them.

This project is still in prototype. There will be no backward-compatible guarantees in the near
feature. Especially do not use this in production.
