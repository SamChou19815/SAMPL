class TuringMachineSimulator {

  fun hi(): Unit = ()

  class Pair<A, B>(a: A, b: B) {
    fun <A, B> getA(p: Pair<A, B>): A = p.a
    fun <A, B> getB(p: Pair<A, B>): B = p.b
    fun <A, B> create(a: A, b: B): Pair<A, B> = Pair{ a = a; b = b }
  }

  class Lst<T>(Nil | Cons of Pair<T, Lst<T>>) {

    private fun fromArrayHelper(index: Int, acc: Lst<String>, arr: StringArray): Lst<String> =
      if index == 0 - 1 then acc
      else
        val newAcc = Lst.Cons(Pair.create(getString(index, arr), acc));
        fromArrayHelper(index - 1, newAcc, arr)

    fun fromArray(arr: StringArray): Lst<String> =
      fromArrayHelper(getStringArrayLength(arr) - 1, Lst.Nil, arr)

    fun stringToCharListHelper(index: Int, acc: Lst<Char>, s: String): Lst<Char> =
      if index == 0 - 1 then acc
      else
        val newAcc = Lst.Cons(Pair.create(getChar(index, s), acc));
        stringToCharListHelper(index - 1, newAcc, s)

    fun stringToCharList(s: String): Lst<Char> =
      stringToCharListHelper(getLength(arr) - 1, Lst.Nil, s)

    fun <T> itemAtIndex(l: Lst<T>, index: Int): T = match l with
      | Nil -> throw<T> "error"
      | Cons p ->
        if index < 0 then throw<T> "error"
        else if index == 0 then Pair.getA(p)
        else itemAtIndex(Pair.getB(p), index - 1)

    fun <T> replaceItemAtIndex(l: Lst<T>, index: Int, replacement: T): Lst<T> = match l with
      | Nil -> throw<T> "error"
      | Cons p ->
        if index < 0 then throw<T> "error"
        else if index == 0 then Lst.Cons(Pair.create(replacement, Pair.getB(p)))
        else Lst.Cons(Pair.create(
          Pair.getA(p), replaceItemAtIndex(Pair.getB(p), index - 1, replacement)
        ))

    fun <T> find(l: Lst<T>, f: (T) -> Bool): T = match l with
      | Nil -> throw<T> "error"
      | Cons p -> if f(Pair.getA(p)) then Pair.getA(p) else find(Pair.getB(p), f)

    fun <T, R> map(l: Lst<T>, f: (T) -> R): Lst<R> = match l with
      | Nil -> Lst.Nil
      | Cons p ->
        val newValue = f(Pair.getA(p));
        val rest = map(Pair.getB(p), f);
        Lst.Cons(Pair.create(newValue, rest))

    fun <T, R> foldLeft(l: Lst<T>, acc: R, f: (R, T) -> R): R = match l with
      | Nil -> acc
      | Cons p ->
        val newAcc = f(acc, Pair.getA(p));
        foldLeft(Pair.getB(p), newAcc, f)

    fun <T, R> foldRight(l: Lst<T>, init: R, f: (T, R) -> R): R = match l with
      | Nil -> init
      | Cons p -> f(Pair.getA(p), foldRight(Pair.getB(p), init, f))

    fun <T> forEach(l: Lst<T>, action: (T) -> Unit): Unit = match l with
      | Nil -> ()
      | Cons p ->
        val ignore = action(Pair.getA(p));
        forEach(Pair.getB(p), action)
  }

  class Direction(Left | Right | Stay) {

    fun left(): Direction = Direction.Left
    fun right(): Direction = Direction.Right
    fun stay(): Direction = Direction.Stay

    fun fromChar(c: Char): Direction =
      if c == '<' then Direction.Left
      else if c == '>' then Direction.Right
      else if c == '-' then Direction.Stay
      else throw<Direction> "error"

  }

  class TransitionRule(
    fromState: String, seeChar: Char,
    toState: String, direction: Direction, overrideChar: Char
  ) {

    fun fromString(s: String): TransitionRule =
      val parts = s.split("_", s);
      val fromState = getString(0, parts);
      val seeChar = getChar(0, getString(1, parts));
      val toState = getString(2, parts);
      val direction = Direction.fromChar(getChar(0, getString(3, parts)));
      val overrideChar = getChar(0, getString(4, parts));
      TransitionRule{
        fromState = fromState; seeChar = seeChar;
        toState = toState; direction = direction; overrideChar = overrideChar
      }

    fun canApply(rule: TransitionRule, fromState: String, seeChar: Char): Bool =
      rule.fromState == fromState && rule.seeChar == seeChar

    fun getToState(rule: TransitionRule): String = rule.toState

    fun getDirection(rule: TransitionRule): Direction = rule.direction

    fun getOverrideChar(rule: TransitionRule): String = rule.overrideChar

  }

  class Result(Yes | No | Halt | StillRunning) {
    fun yes(): Result = Result.Yes
    fun no(): Result = Result.No
    fun halt(): Result = Result.Halt
    fun stillRunning(): Result = Result.StillRunning
  }

  class TuringMachine(
    alphabet: Lst<Char>,
    states: Lst<String>,
    transitions: Lst<TransitionRule>,
    tape: Lst<Char>,
    currentState: String,
    currentPosition: Int
  ) {

    /**
     * Assumption:
     * - Following chars are never in the alphabet: ';', ',', '_', '-', '<', '>'.
     * - The format is these items separated by ';':
     *   1. COMMA Separated AlphaBet
     *   2. COMMA Separated States
     *   3. COMMA Separated Transition Rules
     *   4. Start State
     *   5. Initial Tape Content
     * , where each transition rule has these items separated by '_':
     *   1. Current state
     *   2. Character seen on this state
     *   3. The target state
     *   4. Move direction
     *   5. Character to override on the tape.
     */
    fun fromString(s: String): TuringMachine =
      val parts = split(";", s);
      val alphabet = Lst.fromArray(split(",", getString(0, parts)));
      val states = Lst.fromArray(split(",", getString(1, parts)));
      val transitionRuleRawList = Lst.fromArray(split(",", getString(2, parts)));
      val transitionRules = Lst.map(transitionRuleRawList, TransitionRule.fromString);
      val startState = getString(3, parts);
      val initialTapeContent = Lst.stringToCharList(getString(4, parts));
      TuringMachine{
        alphabet = alphabet; states = states; transitions = transitionRules;
        tape = initialTapeContent; currentState = startState; currentPosition = 0;
      }

    private fun transit(m: TuringMachine): Pair<TuringMachine, Result> =
      val currentChar = Lst.itemAtIndex(m.tape, m.currentPosition);
      val filter = { (r: TransitionRule) ->
        TransitionRule.canApply(r, m.currentState, currentChar)
      };
      val rule = Lst.find(m.transitions, filter);
      val newState = TransitionRule.getNewState(rule);
      val dirOffset = TransitionRule.getDirection(rule);
      val newPosition = m.currentPosition + dirOffset;
      val newChar = TransitionRule.getOverrideChar(rule);
      val newTape = Lst.replaceItemAtIndex(m.tape, m.currentPosition, newChar);
      {
        m with
        tape = newTape; currentState = newState; currentPosition = newPosition
      }

    fun simulate(m: TuringMachine): Pair<TuringMachine, Result> =
      val p = transit(m);
      if Pair.getB(p) == Result.stillRunning() then simulate(Pair.getA(p)) else p
  }

}